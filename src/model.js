const DESK_THEMES_DATA = {
  themes: [
    [
      {
        title: "M. Kerrisk - TLPI",
        blocks: [
          {
            title: "IPC и синхронизация",
            data:
              '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
          },
          {
            title: "Зачем нужна виртуальная память?",
            data:
              "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
          },
          {
            title: "Виртуальная память",
            data:
              "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
          }
        ]
      },
      {
        title: "M. - TLPI",
        blocks: [
          {
            title: "IPC и синхронизация",
            data:
              '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
          },
          {
            title: "Зачем нужна виртуальная память?",
            data:
              "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
          },
          {
            title: "Виртуальная память",

            data:
              "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
          }
        ]
      }
    ],
    [
      {
        title: "M. Kerrisk - TLPI",
        blocks: [
          {
            title: "IPC и синхронизация",
            data:
              '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
          },
          {
            title: "Зачем нужна виртуальная память?",
            data:
              "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
          },
          {
            title: "Виртуальная память",
            data:
              "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
          }
        ]
      },
      {
        title: "M. Kerrisk - TLPI",
        blocks: [
          {
            title: "IPC и синхронизация",
            data:
              '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
          },
          {
            title: "Зачем нужна виртуальная память?",
            data:
              "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
          },
          {
            title: "Виртуальная память",

            data:
              "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
          }
        ]
      }
    ]
  ]
};

export default {
  ALL_DESKS: [
    {
      id: 0,
      title: "Some Hard Theme"
    },
    {
      id: 1,
      title: "Problems"
    },
    {
      id: 2,
      title: "WorldOfLanguage"
    }
  ],

  THEMES_DATA_0: [
    {
      themes: [
        {
          title: "M. Kerrisk - TLPI",
          blocks: [
            {
              title: "IPC и синхронизация",
              data:
                '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
            },
            {
              title: "Зачем нужна виртуальная память?",
              data:
                "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
            },
            {
              title: "Виртуальная память",

              data:
                "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
            }
          ]
        },
        {
          title: "Диск и файловая система",
          blocks: [
            {
              title:
                "Before starting the program, the system initializes all memory",
              data: "bad bad data"
            },
            {
              title: "The mmap() system call",
              data:
                "The mmap() system call creates a new memory mapping in the calling process’s virtual address space.\n\nMappings fall into two categories:\n\n- A file mapping maps a region of a file into the calling process’s virtual memory. Once mapped, the file’s contents can be accessed by operations on the bytes in the corresponding memory region. The pages of the mapping are automatically loaded from the file as required.\n- By contrast, an anonymous mapping doesn’t have a corresponding file. Instead, the pages of the mapping are initialized to 0.\n\nThe memory in one process’s mapping may be shared with mappings in other processes.\nThis can occur either because two processes map the same region of a file or because a child process created by fork() inherits a mapping from its parent. When two or more processes share the same pages, each process may see the changes made by other processes to the contents of the pages, depending on whether the mapping is created as private or shared. When a mapping is private, modifications to the contents of the mapping are not visible to other processes and are not carried through to the underlying file. When a mapping is shared, modifications to the contents of the mapping are visible to other processes sharing the same mapping and are carried through to the underlying file. \n\nMemory mappings serve a variety of purposes, including initialization of a process’s text segment from the corresponding segment of an executable file, allocation of new (zero-filled) memory, file I/O (memory-mapped I/O), and interprocess communication (via a shared mapping)."
            },
            {
              title: "A running Linux system consists of numerous processes",
              data:
                "A running Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD."
            }
          ]
        }
      ]
    }
  ],

  THEMES_DATA_1: [
    {
      themes: [
        {
          title: "M. - TLPI",
          blocks: [
            {
              title: "IPC и синхронизация",
              data:
                '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
            },
            {
              title: "Зачем нужна виртуальная память?",
              data:
                "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
            },
            {
              title: "Виртуальная память",

              data:
                "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
            }
          ]
        },
        {
          title: "Диск и файловая система",
          blocks: [
            {
              title:
                "Before starting the program, the system initializes all memory",
              data: "bad bad data"
            },
            {
              title: "The mmap() system call",
              data:
                "The mmap() system call creates a new memory mapping in the calling process’s virtual address space.\n\nMappings fall into two categories:\n\n- A file mapping maps a region of a file into the calling process’s virtual memory. Once mapped, the file’s contents can be accessed by operations on the bytes in the corresponding memory region. The pages of the mapping are automatically loaded from the file as required.\n- By contrast, an anonymous mapping doesn’t have a corresponding file. Instead, the pages of the mapping are initialized to 0.\n\nThe memory in one process’s mapping may be shared with mappings in other processes.\nThis can occur either because two processes map the same region of a file or because a child process created by fork() inherits a mapping from its parent. When two or more processes share the same pages, each process may see the changes made by other processes to the contents of the pages, depending on whether the mapping is created as private or shared. When a mapping is private, modifications to the contents of the mapping are not visible to other processes and are not carried through to the underlying file. When a mapping is shared, modifications to the contents of the mapping are visible to other processes sharing the same mapping and are carried through to the underlying file. \n\nMemory mappings serve a variety of purposes, including initialization of a process’s text segment from the corresponding segment of an executable file, allocation of new (zero-filled) memory, file I/O (memory-mapped I/O), and interprocess communication (via a shared mapping)."
            },
            {
              title: "A running Linux system consists of numerous processes",
              data:
                "A running Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD."
            }
          ]
        }
      ]
    }
  ],

  THEMES_DATA_2: [
    {
      themes: [
        {
          title: "M. Kerrisk - TLPI",
          blocks: [
            {
              title: "IPC и синхронизация",
              data:
                '<html><img src="http://placekitten.com/164/64" /> <b> A running</b> Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD.</html>'
            },
            {
              title: "Зачем нужна виртуальная память?",
              data:
                "A file system contains the following parts:\n\n- Boot block: This is always the first block in a file system. The boot block is not used by the file system; rather, it contains information used to boot the operating system. Although only one boot block is needed by the operating system, all file systems have a boot block (most of which are unused).\n- Superblock: This is a single block, immediately following the boot block, which contains parameter information about the file system, including:\n– the size of the i-node table;\n– the size of logical blocks in this file system; and\n– the size of the file system in logical blocks.\nDifferent file systems residing on the same physical device can be of different types and sizes, and have different parameter settings (e.g., block size). This is one of the reasons for splitting a disk into multiple partitions.\n- I-node table: Each file or directory in the file system has a unique entry in the i-node table. This entry records various information about the file. I-nodes are discussed in greater detail in the next section. The i-node table is sometimes also\ncalled the i-list.\n- Data blocks: The great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system."
            },
            {
              title: "Виртуальная память",

              data:
                "The memory allocated to each process is composed of a number of parts, usually referred to as segments. These segments are as follows:\n\n- The text segment contains the machine-language instructions of the program run by the process. The text segment is made read-only so that a process doesn’t accidentally modify its own instructions via a bad pointer value. Since many processes may be running the same program, the text segment is made sharable so that a single copy of the program code can be mapped into the virtual address space of all of the processes.\n- The initialized data segment contains global and static variables that are explicitly initialized. The values of these variables are read from the executable file when the program is loaded into memory.\n- The uninitialized data segment contains global and static variables that are not explicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, this is often called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol.” The main reason for placing global and static variables that are initialized into a separate segment from those that are uninitialized is that, when a program is stored on disk, it is not necessary to allocate space for the uninitialized data. Instead, the executable merely needs to record the location and size required for the uninitialized data segment, and this space is allocated by the program loader at run time.\n- The stack is a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function. A frame stores the function’s local variables (so-called automatic variables), arguments, and return value. Stack frames are discussed in more detail in Section 6.5.\n- The heap is an area from which memory (for variables) can be dynamically allocated at run time. The top end of the heap is called the program break. Less commonly used, but more descriptive labels for the initialized and uninitialized data segments are user-initialized data segment and zero-initialized data segment. The size(1) command displays the size of the text, initialized data, and uninitialized\ndata (bss) segments of a binary executable.\n\n\n```\n"
            }
          ]
        },
        {
          title: "Диск и файловая система",
          blocks: [
            {
              title:
                "Before starting the program, the system initializes all memory",
              data: "bad bad data"
            },
            {
              title: "The mmap() system call",
              data:
                "The mmap() system call creates a new memory mapping in the calling process’s virtual address space.\n\nMappings fall into two categories:\n\n- A file mapping maps a region of a file into the calling process’s virtual memory. Once mapped, the file’s contents can be accessed by operations on the bytes in the corresponding memory region. The pages of the mapping are automatically loaded from the file as required.\n- By contrast, an anonymous mapping doesn’t have a corresponding file. Instead, the pages of the mapping are initialized to 0.\n\nThe memory in one process’s mapping may be shared with mappings in other processes.\nThis can occur either because two processes map the same region of a file or because a child process created by fork() inherits a mapping from its parent. When two or more processes share the same pages, each process may see the changes made by other processes to the contents of the pages, depending on whether the mapping is created as private or shared. When a mapping is private, modifications to the contents of the mapping are not visible to other processes and are not carried through to the underlying file. When a mapping is shared, modifications to the contents of the mapping are visible to other processes sharing the same mapping and are carried through to the underlying file. \n\nMemory mappings serve a variety of purposes, including initialization of a process’s text segment from the corresponding segment of an executable file, allocation of new (zero-filled) memory, file I/O (memory-mapped I/O), and interprocess communication (via a shared mapping)."
            },
            {
              title: "A running Linux system consists of numerous processes",
              data:
                "A running Linux system consists of numerous processes, many of which operate independently of each other. Some processes, however, cooperate to achieve their intended purposes, and these processes need methods of communicating with one another and synchronizing their actions.\n\nOne way for processes to communicate is by reading and writing information in disk files. However, for many applications, this is too slow and inflexible.\nTherefore, Linux, like all modern UNIX implementations, provides a rich set of mechanisms for interprocess communication (IPC), including the following:\n\n- signals, which are used to indicate that an event has occurred;\n- pipes (familiar to shell users as the | operator) and FIFOs, which can be used to transfer data between processes;\n- sockets, which can be used to transfer data from one process to another, either\non the same host computer or on different hosts connected by a network;\n- file locking, which allows a process to lock regions of a file in order to prevent other processes from reading or updating the file contents;\n- message queues, which are used to exchange messages (packets of data)  between processes;\n- semaphores, which are used to synchronize the actions of processes; and\n- shared memory, which allows two or more processes to share a piece of memory. When one process changes the contents of the shared memory, all of the other processes can immediately see the changes.\n\nThe wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping functionality, is in part due to their evolution under different variants of the UNIX system and the requirements of various standards. For example, FIFOs and UNIX domain sockets essentially perform the same function of allowing unrelated processes on the same system to exchange data. Both exist in modern UNIX systems because FIFOs came from System V, while sockets came from BSD."
            }
          ]
        }
      ]
    }
  ]
};
